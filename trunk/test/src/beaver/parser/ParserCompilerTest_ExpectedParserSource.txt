package test2;

public abstract class ExprCalc extends beaver.Parser {
	public ExprCalc() throws java.io.IOException {
		super(ExprCalc.class.getResourceAsStream("ExprCalc.bpt"));
	}
	protected abstract Eval makeGoal(Eval eval);
	protected abstract Eval makeExprEval(Expr expr);
	protected abstract Eval makeStmtEval(Stmt stmt);
	protected abstract Stmt makeStmt(Term id, Expr expr);
	protected abstract Expr makeNumberExpr(Term num);
	protected abstract Expr makeVarExpr(Term id);
	protected abstract Expr makeNestedExpr(Expr expr);
	protected abstract Expr makeAddExpr(Expr left, Expr right);
	protected abstract Expr makeSubExpr(Expr left, Expr right);
	protected abstract Expr makeMulExpr(Expr expr, Expr expr2);
	protected abstract Expr makeDivExpr(Expr expr, Expr expr2);
	protected abstract Object makeTerm(Object text, int line, int column);
	protected Object reduce(Object[] stack, int top, int rule) {
		switch (rule) {
			case 0: { // Goal = Eval
				return makeGoal((Eval) stack[top]);
			}
			case 1: { // Eval = { Expr } Expr
				return makeExprEval((Expr) stack[top]);
			}
			case 2: { // Eval = { Stmt } Stmt
				return makeStmtEval((Stmt) stack[top]);
			}
			case 3: { // Stmt = ID "=" Expr ";"
				return makeStmt((Term) stack[top + 3], (Expr) stack[top + 1]);
			}
			case 4: { // Expr = { Number } NUM
				return makeNumberExpr((Term) stack[top]);
			}
			case 5: { // Expr = { Var } ID
				return makeVarExpr((Term) stack[top]);
			}
			case 6: { // Expr = { Nested } "(" Expr ")"
				return makeNestedExpr((Expr) stack[top + 1]);
			}
			case 7: { // Expr = { Add } left:Expr "+" right:Expr
				return makeAddExpr((Expr) stack[top + 2], (Expr) stack[top]);
			}
			case 8: { // Expr = { Sub } left:Expr "-" right:Expr
				return makeSubExpr((Expr) stack[top + 2], (Expr) stack[top]);
			}
			case 9: { // Expr = { Mul } Expr "*" Expr
				return makeMulExpr((Expr) stack[top + 2], (Expr) stack[top]);
			}
			case 10: { // Expr = { Div } Expr "/" Expr
				return makeDivExpr((Expr) stack[top + 2], (Expr) stack[top]);
			}
		}
		throw new IndexOutOfBoundsException("production #" + rule);
	}
}
