package test2;

public class ExprCalc4 extends beaver.Parser {
	public ExprCalc4() throws java.io.IOException {
		super(ExprCalc4.class.getResourceAsStream("ExprCalc4.bpt"));
	}
	protected Eval makeEval(StmtList optStmtList, Expr optExpr) {
		return new Eval(optStmtList, optExpr);
	}
	protected StmtList makeOptStmtList() {
		return new StmtList();
	}
	protected StmtList makeNewStmtList(Stmt stmt) {
		return new StmtList(stmt);
	}
	protected StmtList makeExtStmtList(StmtList stmtList, Stmt stmt) {
		return stmtList.add(stmt);
	}
	protected Stmt makeStmt(Term id, Expr expr) {
		return new Stmt(id, expr);
	}
	protected Expr makeNumExpr(Term num) {
		return new NumExpr(num);
	}
	protected Expr makeVarExpr(Term id) {
		return new VarExpr(id);
	}
	protected Expr makeAddExpr(Expr left, Expr right) {
		return new AddExpr(left, right);
	}
	protected Expr makeSubExpr(Expr left, Expr right) {
		return new SubExpr(left, right);
	}
	protected Expr makeMulExpr(Expr left, Expr right) {
		return new MulExpr(left, right);
	}
	protected Expr makeDivExpr(Expr left, Expr right) {
		return new DivExpr(left, right);
	}
	protected Object makeTerm(Object text, int line, int column) {
		return new Term((String) text);
	}
	protected Object reduce(Object[] stack, int top, int rule) {
		switch (rule) {
			case 0: { // Eval = OptStmtList OptExpr
				StmtList optStmtList = (StmtList) stack[top + 1];
				Expr optExpr = (Expr) stack[top];

				return makeEval(optStmtList, optExpr);
			}
			case 1: { // OptStmtList = StmtList

				return stack[top];
			}
			case 2: { // OptStmtList =

				return makeOptStmtList();
			}
			case 3: { // OptExpr = Expr

				return stack[top];
			}
			case 4: { // OptExpr =

				return null;
			}
			case 5: { // StmtList = { New } Stmt
				Stmt stmt = (Stmt) stack[top];

				return makeNewStmtList(stmt);
			}
			case 6: { // StmtList = { Ext } StmtList Stmt
				StmtList stmtList = (StmtList) stack[top + 1];
				Stmt stmt = (Stmt) stack[top];

				return makeExtStmtList(stmtList, stmt);
			}
			case 7: { // Stmt = ID "=" Expr ";"
				Term id = (Term) stack[top + 3];
				Expr expr = (Expr) stack[top + 1];

				return makeStmt(id, expr);
			}
			case 8: { // Expr = { Num } NUM
				Term num = (Term) stack[top];

				return makeNumExpr(num);
			}
			case 9: { // Expr = { Var } ID
				Term id = (Term) stack[top];

				return makeVarExpr(id);
			}
			case 10: { // Expr = { Nested } "(" Expr ")"

				return stack[top + 1];
			}
			case 11: { // Expr = { Add } left:Expr "+" right:Expr
				Expr left = (Expr) stack[top + 2];
				Expr right = (Expr) stack[top];

				return makeAddExpr(left, right);
			}
			case 12: { // Expr = { Sub } left:Expr "-" right:Expr
				Expr left = (Expr) stack[top + 2];
				Expr right = (Expr) stack[top];

				return makeSubExpr(left, right);
			}
			case 13: { // Expr = { Mul } left:Expr "*" right:Expr
				Expr left = (Expr) stack[top + 2];
				Expr right = (Expr) stack[top];

				return makeMulExpr(left, right);
			}
			case 14: { // Expr = { Div } left:Expr "/" right:Expr
				Expr left = (Expr) stack[top + 2];
				Expr right = (Expr) stack[top];

				return makeDivExpr(left, right);
			}
		}
		throw new IndexOutOfBoundsException("production #" + rule);
	}
}
