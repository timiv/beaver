public abstract class ExprCalc3 extends beaver.Parser {
	public ExprCalc3() {
		super(ExprCalc3.class.getResourceAsStream("ExprCalc3.bpt"));
	}
	protected abstract Eval makeEval(StmtList optStmtList, Expr optExpr);
	protected abstract StmtList makeOptStmtList();
	protected abstract StmtList makeNewStmtList(Stmt stmt);
	protected abstract StmtList makeExtStmtList(StmtList stmtList, Stmt stmt);
	protected abstract Stmt makeStmt(Term id, Expr expr);
	protected abstract Expr makeNumExpr(Term num);
	protected abstract Expr makeVarExpr(Term id);
	protected abstract Expr makeAddExpr(Expr left, Expr right);
	protected abstract Expr makeSubExpr(Expr left, Expr right);
	protected abstract Expr makeMulExpr(Expr left, Expr right);
	protected abstract Expr makeDivExpr(Expr left, Expr right);
	protected Symbol reduce(Symbol[] stack, int top, int rule) {
		switch (rule) {
			case 0: { // Eval = OptStmtList OptExpr
				StmtList optStmtList = (StmtList) stack[top + 1].value();
				Expr optExpr = (Expr) stack[top].value();

				return symbol(makeEval(optStmtList, optExpr));
			}
			case 1: { // OptStmtList = StmtList
				StmtList stmtList = (StmtList) stack[top].value();

				return symbol(stmtList);
			}
			case 2: { // OptStmtList =

				return symbol(makeOptStmtList());
			}
			case 3: { // OptExpr = Expr
				Expr expr = (Expr) stack[top].value();

				return symbol(expr);
			}
			case 4: { // OptExpr =

				return symbol(null);
			}
			case 5: { // StmtList = { New } Stmt
				Stmt stmt = (Stmt) stack[top].value();

				return symbol(makeNewStmtList(stmt));
			}
			case 6: { // StmtList = { Ext } StmtList Stmt
				StmtList stmtList = (StmtList) stack[top + 1].value();
				Stmt stmt = (Stmt) stack[top].value();

				return symbol(makeExtStmtList(stmtList, stmt));
			}
			case 7: { // Stmt = ID "=" Expr ";"
				Term id = (Term) stack[top + 3].value();
				Expr expr = (Expr) stack[top + 1].value();

				return symbol(makeStmt(id, expr));
			}
			case 8: { // Expr = { Num } NUM
				Term num = (Term) stack[top].value();

				return symbol(makeNumExpr(num));
			}
			case 9: { // Expr = { Var } ID
				Term id = (Term) stack[top].value();

				return symbol(makeVarExpr(id));
			}
			case 10: { // Expr = { Nested } "(" Expr ")"
				Expr expr = (Expr) stack[top + 1].value();

				return symbol(expr);
			}
			case 11: { // Expr = { Add } left:Expr "+" right:Expr
				Expr left = (Expr) stack[top + 2].value();
				Expr right = (Expr) stack[top].value();

				return symbol(makeAddExpr(left, right));
			}
			case 12: { // Expr = { Sub } left:Expr "-" right:Expr
				Expr left = (Expr) stack[top + 2].value();
				Expr right = (Expr) stack[top].value();

				return symbol(makeSubExpr(left, right));
			}
			case 13: { // Expr = { Mul } left:Expr "*" right:Expr
				Expr left = (Expr) stack[top + 2].value();
				Expr right = (Expr) stack[top].value();

				return symbol(makeMulExpr(left, right));
			}
			case 14: { // Expr = { Div } left:Expr "/" right:Expr
				Expr left = (Expr) stack[top + 2].value();
				Expr right = (Expr) stack[top].value();

				return symbol(makeDivExpr(left, right));
			}
		}
		throw new IndexOutOfBoundsException("production #" + rule);
	}
}
